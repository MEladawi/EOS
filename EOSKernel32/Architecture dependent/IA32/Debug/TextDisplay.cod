; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\GRAD\EOS - (KB)\EOSKernel32\Architecture dependent\IA32\TextDisplay.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_VGA_Ram
PUBLIC	_X
PUBLIC	_Y
PUBLIC	_Color
_DATA	SEGMENT
_VGA_Ram DD	0b8000H
_X	DB	01H
_Y	DB	01H
_Color	DB	0f0H
	ORG $+1
$SG1100	DB	'Invalid command!', 00H
	ORG $+3
$SG1101	DB	'XiOS Terminal#', 00H
_DATA	ENDS
PUBLIC	_EOS_ClearBody
; Function compile flags: /Odtpy
; File d:\grad\eos - (kb)\eoskernel32\architecture dependent\ia32\textdisplay.c
_TEXT	SEGMENT
_i$ = -4						; size = 4
_EOS_ClearBody PROC

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 99   : 	uint32 i;
; 100  : 	for ( i=80; i<80*24; i++) VGA_Ram[i] = ( ((uint16)(Backcolor)) << 8) | ' '; //24 = 25 - 1 (for banner).

  00004	c7 45 fc 50 00
	00 00		 mov	 DWORD PTR _i$[ebp], 80	; 00000050H
  0000b	eb 09		 jmp	 SHORT $LN3@EOS_ClearB
$LN2@EOS_ClearB:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@EOS_ClearB:
  00016	81 7d fc 80 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 1920 ; 00000780H
  0001d	73 13		 jae	 SHORT $LN1@EOS_ClearB
  0001f	b9 20 f0 00 00	 mov	 ecx, 61472		; 0000f020H
  00024	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00027	a1 00 00 00 00	 mov	 eax, DWORD PTR _VGA_Ram
  0002c	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00030	eb db		 jmp	 SHORT $LN2@EOS_ClearB
$LN1@EOS_ClearB:

; 101  : 	SetCoordinate(1, 1);

  00032	6a 01		 push	 1
  00034	6a 01		 push	 1
  00036	e8 00 00 00 00	 call	 _SetCoordinate
  0003b	83 c4 08	 add	 esp, 8

; 102  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_EOS_ClearBody ENDP
; Function compile flags: /Odtpy
_CoX$ = 8						; size = 1
_CoY$ = 12						; size = 1
_SetCoordinate PROC

; 80   : {

  00050	55		 push	 ebp
  00051	8b ec		 mov	 ebp, esp

; 81   : 	if (CoX <= 79) X= CoX;

  00053	0f b6 45 08	 movzx	 eax, BYTE PTR _CoX$[ebp]
  00057	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0005a	7f 09		 jg	 SHORT $LN2@SetCoordin
  0005c	8a 4d 08	 mov	 cl, BYTE PTR _CoX$[ebp]
  0005f	88 0d 00 00 00
	00		 mov	 BYTE PTR _X, cl
$LN2@SetCoordin:

; 82   : 	if (CoY <= 24) Y= CoY;

  00065	0f b6 55 0c	 movzx	 edx, BYTE PTR _CoY$[ebp]
  00069	83 fa 18	 cmp	 edx, 24			; 00000018H
  0006c	7f 08		 jg	 SHORT $LN3@SetCoordin
  0006e	8a 45 0c	 mov	 al, BYTE PTR _CoY$[ebp]
  00071	a2 00 00 00 00	 mov	 BYTE PTR _Y, al
$LN3@SetCoordin:

; 83   : }

  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
_SetCoordinate ENDP
_TEXT	ENDS
PUBLIC	_EOS_ClearScrean
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Background$ = 8					; size = 1
_EOS_ClearScrean PROC

; 107  : {

  00080	55		 push	 ebp
  00081	8b ec		 mov	 ebp, esp
  00083	51		 push	 ecx

; 108  : 	uint32 i;
; 109  : 	for ( i=0; i<80*25; i++) VGA_Ram[i] = ( ((uint16)(Background)) << 8) | ' ';

  00084	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0008b	eb 09		 jmp	 SHORT $LN3@EOS_ClearS
$LN2@EOS_ClearS:
  0008d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00090	83 c0 01	 add	 eax, 1
  00093	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@EOS_ClearS:
  00096	81 7d fc d0 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 2000 ; 000007d0H
  0009d	73 18		 jae	 SHORT $LN1@EOS_ClearS
  0009f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Background$[ebp]
  000a3	c1 e1 08	 shl	 ecx, 8
  000a6	83 c9 20	 or	 ecx, 32			; 00000020H
  000a9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000ac	a1 00 00 00 00	 mov	 eax, DWORD PTR _VGA_Ram
  000b1	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  000b5	eb d6		 jmp	 SHORT $LN2@EOS_ClearS
$LN1@EOS_ClearS:

; 110  : 	SetCoordinate(0, 0);

  000b7	6a 00		 push	 0
  000b9	6a 00		 push	 0
  000bb	e8 00 00 00 00	 call	 _SetCoordinate
  000c0	83 c4 08	 add	 esp, 8

; 111  : }

  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
_EOS_ClearScrean ENDP
_TEXT	ENDS
PUBLIC	_EOS_ClearHeader
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Background$ = 8					; size = 1
_EOS_ClearHeader PROC

; 115  : {

  000d0	55		 push	 ebp
  000d1	8b ec		 mov	 ebp, esp
  000d3	51		 push	 ecx

; 116  : 	uint32 i;
; 117  : 	for ( i=0; i<80; i++) VGA_Ram[i] = ( ((uint16)(Background)) << 8) | ' ';		//first raw for header (from 0 to 79)

  000d4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000db	eb 09		 jmp	 SHORT $LN3@EOS_ClearH
$LN2@EOS_ClearH:
  000dd	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000e0	83 c0 01	 add	 eax, 1
  000e3	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@EOS_ClearH:
  000e6	83 7d fc 50	 cmp	 DWORD PTR _i$[ebp], 80	; 00000050H
  000ea	73 18		 jae	 SHORT $LN1@EOS_ClearH
  000ec	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Background$[ebp]
  000f0	c1 e1 08	 shl	 ecx, 8
  000f3	83 c9 20	 or	 ecx, 32			; 00000020H
  000f6	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000f9	a1 00 00 00 00	 mov	 eax, DWORD PTR _VGA_Ram
  000fe	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00102	eb d9		 jmp	 SHORT $LN2@EOS_ClearH
$LN1@EOS_ClearH:

; 118  : 	SetCoordinate(0, 0);

  00104	6a 00		 push	 0
  00106	6a 00		 push	 0
  00108	e8 00 00 00 00	 call	 _SetCoordinate
  0010d	83 c4 08	 add	 esp, 8

; 119  : }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c3		 ret	 0
_EOS_ClearHeader ENDP
_TEXT	ENDS
PUBLIC	_EOS_ClearTrailer
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_i$ = -4						; size = 4
_Background$ = 8					; size = 1
_EOS_ClearTrailer PROC

; 123  : {

  00120	55		 push	 ebp
  00121	8b ec		 mov	 ebp, esp
  00123	51		 push	 ecx

; 124  : 	uint32 i;
; 125  : 	for ( i=80*24; i<80*25; i++) VGA_Ram[i] = ( ((uint16)(Background)) << 8) | ' '; //Last raw for trailer

  00124	c7 45 fc 80 07
	00 00		 mov	 DWORD PTR _i$[ebp], 1920 ; 00000780H
  0012b	eb 09		 jmp	 SHORT $LN3@EOS_ClearT
$LN2@EOS_ClearT:
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00130	83 c0 01	 add	 eax, 1
  00133	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@EOS_ClearT:
  00136	81 7d fc d0 07
	00 00		 cmp	 DWORD PTR _i$[ebp], 2000 ; 000007d0H
  0013d	73 18		 jae	 SHORT $LN1@EOS_ClearT
  0013f	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Background$[ebp]
  00143	c1 e1 08	 shl	 ecx, 8
  00146	83 c9 20	 or	 ecx, 32			; 00000020H
  00149	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  0014c	a1 00 00 00 00	 mov	 eax, DWORD PTR _VGA_Ram
  00151	66 89 0c 50	 mov	 WORD PTR [eax+edx*2], cx
  00155	eb d6		 jmp	 SHORT $LN2@EOS_ClearT
$LN1@EOS_ClearT:

; 126  : 	SetCoordinate(0, 24);

  00157	6a 18		 push	 24			; 00000018H
  00159	6a 00		 push	 0
  0015b	e8 00 00 00 00	 call	 _SetCoordinate
  00160	83 c4 08	 add	 esp, 8

; 127  : }

  00163	8b e5		 mov	 esp, ebp
  00165	5d		 pop	 ebp
  00166	c3		 ret	 0
_EOS_ClearTrailer ENDP
_TEXT	ENDS
PUBLIC	_EOS_PrintString
EXTRN	_strlen:PROC
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_i$ = -4						; size = 4
_string$ = 8						; size = 4
_PrintColor$ = 12					; size = 1
_XCor$ = 16						; size = 1
_YCor$ = 20						; size = 1
_EOS_PrintString PROC

; 131  : {

  00170	55		 push	 ebp
  00171	8b ec		 mov	 ebp, esp
  00173	51		 push	 ecx

; 132  : 	
; 133  : 	uint32 i;
; 134  : 
; 135  : 	if (!string) return;

  00174	83 7d 08 00	 cmp	 DWORD PTR _string$[ebp], 0
  00178	75 02		 jne	 SHORT $LN4@EOS_PrintS
  0017a	eb 52		 jmp	 SHORT $LN5@EOS_PrintS
$LN4@EOS_PrintS:

; 136  : 
; 137  : 	SetCoordinate(XCor, YCor);

  0017c	0f b6 45 14	 movzx	 eax, BYTE PTR _YCor$[ebp]
  00180	50		 push	 eax
  00181	0f b6 4d 10	 movzx	 ecx, BYTE PTR _XCor$[ebp]
  00185	51		 push	 ecx
  00186	e8 00 00 00 00	 call	 _SetCoordinate
  0018b	83 c4 08	 add	 esp, 8

; 138  : 	Color = PrintColor;

  0018e	8a 55 0c	 mov	 dl, BYTE PTR _PrintColor$[ebp]
  00191	88 15 00 00 00
	00		 mov	 BYTE PTR _Color, dl

; 139  : 	for (i=0; i< ((uint32)(strlen(string))); i++)

  00197	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0019e	eb 09		 jmp	 SHORT $LN3@EOS_PrintS
$LN2@EOS_PrintS:
  001a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  001a3	83 c0 01	 add	 eax, 1
  001a6	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@EOS_PrintS:
  001a9	8b 4d 08	 mov	 ecx, DWORD PTR _string$[ebp]
  001ac	51		 push	 ecx
  001ad	e8 00 00 00 00	 call	 _strlen
  001b2	83 c4 04	 add	 esp, 4
  001b5	39 45 fc	 cmp	 DWORD PTR _i$[ebp], eax
  001b8	73 14		 jae	 SHORT $LN5@EOS_PrintS

; 140  : 		PrintChar(string[i]);

  001ba	8b 55 08	 mov	 edx, DWORD PTR _string$[ebp]
  001bd	03 55 fc	 add	 edx, DWORD PTR _i$[ebp]
  001c0	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  001c3	50		 push	 eax
  001c4	e8 00 00 00 00	 call	 _PrintChar
  001c9	83 c4 04	 add	 esp, 4
  001cc	eb d2		 jmp	 SHORT $LN2@EOS_PrintS
$LN5@EOS_PrintS:

; 141  : 	
; 142  : 	
; 143  : }

  001ce	8b e5		 mov	 esp, ebp
  001d0	5d		 pop	 ebp
  001d1	c3		 ret	 0
_EOS_PrintString ENDP
; Function compile flags: /Odtpy
tv68 = -12						; size = 4
_POINTER$1030 = -8					; size = 4
_Attribute$ = -4					; size = 2
_Character$ = 8						; size = 1
_PrintChar PROC

; 47   : {

  001e0	55		 push	 ebp
  001e1	8b ec		 mov	 ebp, esp
  001e3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 48   : 
; 49   : 	uint16 Attribute = ((uint16) Color) << 8;

  001e6	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _Color
  001ed	c1 e0 08	 shl	 eax, 8
  001f0	66 89 45 fc	 mov	 WORD PTR _Attribute$[ebp], ax

; 50   : 
; 51   : 	switch (Character) 

  001f4	8a 4d 08	 mov	 cl, BYTE PTR _Character$[ebp]
  001f7	88 4d f4	 mov	 BYTE PTR tv68[ebp], cl
  001fa	80 7d f4 09	 cmp	 BYTE PTR tv68[ebp], 9
  001fe	74 08		 je	 SHORT $LN4@PrintChar
  00200	80 7d f4 0a	 cmp	 BYTE PTR tv68[ebp], 10	; 0000000aH
  00204	74 17		 je	 SHORT $LN3@PrintChar
  00206	eb 1c		 jmp	 SHORT $LN2@PrintChar
$LN4@PrintChar:

; 52   : 	{
; 53   : 
; 54   : 	//Tab
; 55   : 	case 0x09:
; 56   : 		X = (X + 8) & ~(8 - 1);

  00208	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _X
  0020f	83 c2 08	 add	 edx, 8
  00212	83 e2 f8	 and	 edx, -8			; fffffff8H
  00215	88 15 00 00 00
	00		 mov	 BYTE PTR _X, dl

; 57   : 		break;

  0021b	eb 43		 jmp	 SHORT $LN7@PrintChar
$LN3@PrintChar:

; 58   : 
; 59   : 	//New Line
; 60   : 	case '\n':
; 61   : 		IncY();

  0021d	e8 00 00 00 00	 call	 _IncY

; 62   : 		break;

  00222	eb 3c		 jmp	 SHORT $LN7@PrintChar
$LN2@PrintChar:

; 63   : 
; 64   : 	//Any PRINTABLE character; printable  characters are after ' ' in ascii ;)
; 65   : 	default:
; 66   : 		if (Character >= ' ') 

  00224	0f be 45 08	 movsx	 eax, BYTE PTR _Character$[ebp]
  00228	83 f8 20	 cmp	 eax, 32			; 00000020H
  0022b	7c 33		 jl	 SHORT $LN7@PrintChar

; 67   : 		{
; 68   : 			uint16 * POINTER	=	VGA_Ram + (Y * 80 + X); 

  0022d	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _Y
  00234	6b c9 50	 imul	 ecx, 80			; 00000050H
  00237	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _X
  0023e	03 ca		 add	 ecx, edx
  00240	a1 00 00 00 00	 mov	 eax, DWORD PTR _VGA_Ram
  00245	8d 0c 48	 lea	 ecx, DWORD PTR [eax+ecx*2]
  00248	89 4d f8	 mov	 DWORD PTR _POINTER$1030[ebp], ecx

; 69   : 			* POINTER			=	Character | Attribute;

  0024b	0f be 55 08	 movsx	 edx, BYTE PTR _Character$[ebp]
  0024f	0f b7 45 fc	 movzx	 eax, WORD PTR _Attribute$[ebp]
  00253	0b d0		 or	 edx, eax
  00255	8b 4d f8	 mov	 ecx, DWORD PTR _POINTER$1030[ebp]
  00258	66 89 11	 mov	 WORD PTR [ecx], dx

; 70   : 			IncX();

  0025b	e8 00 00 00 00	 call	 _IncX
$LN7@PrintChar:

; 71   : 		}
; 72   : 
; 73   : 	}
; 74   : 
; 75   : }

  00260	8b e5		 mov	 esp, ebp
  00262	5d		 pop	 ebp
  00263	c3		 ret	 0
_PrintChar ENDP
; Function compile flags: /Odtpy
_IncX	PROC

; 18   : {

  00270	55		 push	 ebp
  00271	8b ec		 mov	 ebp, esp

; 19   : 	if (X < 79) X++;

  00273	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _X
  0027a	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0027d	7d 11		 jge	 SHORT $LN2@IncX
  0027f	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _X
  00285	80 c1 01	 add	 cl, 1
  00288	88 0d 00 00 00
	00		 mov	 BYTE PTR _X, cl
  0028e	eb 05		 jmp	 SHORT $LN3@IncX
$LN2@IncX:

; 20   : 	else IncY();

  00290	e8 00 00 00 00	 call	 _IncY
$LN3@IncX:

; 21   : }

  00295	5d		 pop	 ebp
  00296	c3		 ret	 0
_IncX	ENDP
; Function compile flags: /Odtpy
_IncY	PROC

; 27   : {

  002a0	55		 push	 ebp
  002a1	8b ec		 mov	 ebp, esp

; 28   : 	if (Y < 23) { Y++; X=1; }

  002a3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _Y
  002aa	83 f8 17	 cmp	 eax, 23			; 00000017H
  002ad	7d 18		 jge	 SHORT $LN2@IncY
  002af	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _Y
  002b5	80 c1 01	 add	 cl, 1
  002b8	88 0d 00 00 00
	00		 mov	 BYTE PTR _Y, cl
  002be	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _X, 1
  002c5	eb 1e		 jmp	 SHORT $LN3@IncY
$LN2@IncY:

; 29   : 	else {Y =1; X=1; EOS_ClearBody(Color);}

  002c7	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _Y, 1
  002ce	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _X, 1
  002d5	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _Color
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 _EOS_ClearBody
  002e2	83 c4 04	 add	 esp, 4
$LN3@IncY:

; 30   : }

  002e5	5d		 pop	 ebp
  002e6	c3		 ret	 0
_IncY	ENDP
_TEXT	ENDS
PUBLIC	_XPrintChar
; Function compile flags: /Odtpy
_TEXT	SEGMENT
tv68 = -12						; size = 4
_POINTER$1104 = -8					; size = 4
_Attribute$ = -4					; size = 2
_Character$ = 8						; size = 1
_Color$ = 12						; size = 1
_XPrintChar PROC

; 147  : {

  002f0	55		 push	 ebp
  002f1	8b ec		 mov	 ebp, esp
  002f3	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 148  : 
; 149  : 	uint16 Attribute = ((uint16) Color) << 8;

  002f6	0f b6 45 0c	 movzx	 eax, BYTE PTR _Color$[ebp]
  002fa	c1 e0 08	 shl	 eax, 8
  002fd	66 89 45 fc	 mov	 WORD PTR _Attribute$[ebp], ax

; 150  : 
; 151  : 	switch (Character) 

  00301	8a 4d 08	 mov	 cl, BYTE PTR _Character$[ebp]
  00304	88 4d f4	 mov	 BYTE PTR tv68[ebp], cl
  00307	80 7d f4 08	 cmp	 BYTE PTR tv68[ebp], 8
  0030b	74 29		 je	 SHORT $LN5@XPrintChar
  0030d	80 7d f4 09	 cmp	 BYTE PTR tv68[ebp], 9
  00311	74 0b		 je	 SHORT $LN6@XPrintChar
  00313	80 7d f4 0a	 cmp	 BYTE PTR tv68[ebp], 10	; 0000000aH
  00317	74 56		 je	 SHORT $LN3@XPrintChar
  00319	e9 a1 00 00 00	 jmp	 $LN2@XPrintChar
$LN6@XPrintChar:

; 152  : 	{
; 153  : 
; 154  : 	//Tab
; 155  : 	case 0x09:
; 156  : 		X = (X + 8) & ~(8 - 1);

  0031e	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _X
  00325	83 c2 08	 add	 edx, 8
  00328	83 e2 f8	 and	 edx, -8			; fffffff8H
  0032b	88 15 00 00 00
	00		 mov	 BYTE PTR _X, dl

; 157  : 		break;

  00331	e9 c6 00 00 00	 jmp	 $LN9@XPrintChar
$LN5@XPrintChar:

; 158  : 
; 159  : 	case 0x08:
; 160  : 		if (X>15) {X--; PrintChar(' '); X--; }

  00336	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _X
  0033d	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  00340	7e 28		 jle	 SHORT $LN4@XPrintChar
  00342	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _X
  00348	80 e9 01	 sub	 cl, 1
  0034b	88 0d 00 00 00
	00		 mov	 BYTE PTR _X, cl
  00351	6a 20		 push	 32			; 00000020H
  00353	e8 00 00 00 00	 call	 _PrintChar
  00358	83 c4 04	 add	 esp, 4
  0035b	8a 15 00 00 00
	00		 mov	 dl, BYTE PTR _X
  00361	80 ea 01	 sub	 dl, 1
  00364	88 15 00 00 00
	00		 mov	 BYTE PTR _X, dl
$LN4@XPrintChar:

; 161  : 		break;

  0036a	e9 8d 00 00 00	 jmp	 $LN9@XPrintChar
$LN3@XPrintChar:

; 162  : 
; 163  : 	//New Line
; 164  : 	case 0x0A:
; 165  : 		CIncY();

  0036f	e8 00 00 00 00	 call	 _CIncY

; 166  : 		EOS_PrintString("Invalid command!", 0xF4, X, Y);

  00374	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _Y
  0037b	50		 push	 eax
  0037c	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _X
  00383	51		 push	 ecx
  00384	68 f4 00 00 00	 push	 244			; 000000f4H
  00389	68 00 00 00 00	 push	 OFFSET $SG1100
  0038e	e8 00 00 00 00	 call	 _EOS_PrintString
  00393	83 c4 10	 add	 esp, 16			; 00000010H

; 167  : 		CIncY();

  00396	e8 00 00 00 00	 call	 _CIncY

; 168  : 		EOS_PrintString("XiOS Terminal#", Color, X, Y);

  0039b	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR _Y
  003a2	52		 push	 edx
  003a3	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _X
  003aa	50		 push	 eax
  003ab	0f b6 4d 0c	 movzx	 ecx, BYTE PTR _Color$[ebp]
  003af	51		 push	 ecx
  003b0	68 00 00 00 00	 push	 OFFSET $SG1101
  003b5	e8 00 00 00 00	 call	 _EOS_PrintString
  003ba	83 c4 10	 add	 esp, 16			; 00000010H

; 169  : 		break;

  003bd	eb 3d		 jmp	 SHORT $LN9@XPrintChar
$LN2@XPrintChar:

; 170  : 
; 171  : 	//Any PRINTABLE character; printable  characters are after ' ' in ascii ;)
; 172  : 	default:
; 173  : 		if (Character >= 0x20) 

  003bf	0f be 55 08	 movsx	 edx, BYTE PTR _Character$[ebp]
  003c3	83 fa 20	 cmp	 edx, 32			; 00000020H
  003c6	7c 34		 jl	 SHORT $LN9@XPrintChar

; 174  : 		{
; 175  : 			uint16 * POINTER	=	VGA_Ram + (Y * 80 + X); 

  003c8	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _Y
  003cf	6b c0 50	 imul	 eax, 80			; 00000050H
  003d2	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _X
  003d9	03 c1		 add	 eax, ecx
  003db	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _VGA_Ram
  003e1	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  003e4	89 45 f8	 mov	 DWORD PTR _POINTER$1104[ebp], eax

; 176  : 			* POINTER			=	Character | Attribute;

  003e7	0f be 4d 08	 movsx	 ecx, BYTE PTR _Character$[ebp]
  003eb	0f b7 55 fc	 movzx	 edx, WORD PTR _Attribute$[ebp]
  003ef	0b ca		 or	 ecx, edx
  003f1	8b 45 f8	 mov	 eax, DWORD PTR _POINTER$1104[ebp]
  003f4	66 89 08	 mov	 WORD PTR [eax], cx

; 177  : 			CIncX();

  003f7	e8 00 00 00 00	 call	 _CIncX
$LN9@XPrintChar:

; 178  : 		}
; 179  : 
; 180  : 	}
; 181  : 
; 182  : }

  003fc	8b e5		 mov	 esp, ebp
  003fe	5d		 pop	 ebp
  003ff	c3		 ret	 0
_XPrintChar ENDP
; Function compile flags: /Odtpy
_CIncY	PROC

; 33   : {

  00400	55		 push	 ebp
  00401	8b ec		 mov	 ebp, esp

; 34   : 	if (Y < 23) { Y++; X=1; }

  00403	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _Y
  0040a	83 f8 17	 cmp	 eax, 23			; 00000017H
  0040d	7d 18		 jge	 SHORT $LN2@CIncY
  0040f	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _Y
  00415	80 c1 01	 add	 cl, 1
  00418	88 0d 00 00 00
	00		 mov	 BYTE PTR _Y, cl
  0041e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _X, 1
  00425	eb 1b		 jmp	 SHORT $LN3@CIncY
$LN2@CIncY:

; 35   : 	else {Y =1; X=1; EOS_ClearBody(0xF0);}

  00427	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _Y, 1
  0042e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _X, 1
  00435	68 f0 00 00 00	 push	 240			; 000000f0H
  0043a	e8 00 00 00 00	 call	 _EOS_ClearBody
  0043f	83 c4 04	 add	 esp, 4
$LN3@CIncY:

; 36   : }

  00442	5d		 pop	 ebp
  00443	c3		 ret	 0
_CIncY	ENDP
; Function compile flags: /Odtpy
_CIncX	PROC

; 40   : {

  00450	55		 push	 ebp
  00451	8b ec		 mov	 ebp, esp

; 41   : 	if (X < 79) X++;

  00453	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _X
  0045a	83 f8 4f	 cmp	 eax, 79			; 0000004fH
  0045d	7d 11		 jge	 SHORT $LN2@CIncX
  0045f	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _X
  00465	80 c1 01	 add	 cl, 1
  00468	88 0d 00 00 00
	00		 mov	 BYTE PTR _X, cl
  0046e	eb 05		 jmp	 SHORT $LN3@CIncX
$LN2@CIncX:

; 42   : 	else CIncY();

  00470	e8 00 00 00 00	 call	 _CIncY
$LN3@CIncX:

; 43   : }

  00475	5d		 pop	 ebp
  00476	c3		 ret	 0
_CIncX	ENDP
_TEXT	ENDS
END
