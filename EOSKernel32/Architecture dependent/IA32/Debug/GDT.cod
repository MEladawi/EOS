; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\GRAD\EOS - (KB)\EOSKernel32\Architecture dependent\IA32\GDT.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_GDT_Setup
_BSS	SEGMENT
_GDT	DQ	03H DUP (?)
_GDTR	DF	01H DUP (?)
; Function compile flags: /Odtpy
; File d:\grad\eos - (kb)\eoskernel32\architecture dependent\ia32\gdt.c
_BSS	ENDS
_TEXT	SEGMENT
_GDT_Setup PROC

; 107  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 108  : 
; 109  : 	//Add the null descriptor
; 110  : 	GDT_AddDescriptor(0, 0, 0, 0);

  00003	6a 00		 push	 0
  00005	6a 00		 push	 0
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	e8 00 00 00 00	 call	 _GDT_AddDescriptor
  00010	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 
; 112  : 
; 113  : 	//Add the code descriptor
; 114  : 	GDT_AddDescriptor(1, 0, 0x000FFFFF,//the flag field is ORing of fields in header!!
; 115  : 		 GDT_Flags_Type_ReadWrite	//Readable Code segment
; 116  : 		|GDT_Flags_Type_Code		//Code segment
; 117  : 		|GDT_Flags_CodeORData		//Not system segment
; 118  : 		|GDT_Flags_Present			//Present segment
; 119  : 		|GDT_Flags_DB32Bit			//32bit segment
; 120  : 		|GDT_Flags_Granularity4GB);	//Up to 4GiB segment

  00013	68 9a c0 00 00	 push	 49306			; 0000c09aH
  00018	68 ff ff 0f 00	 push	 1048575			; 000fffffH
  0001d	6a 00		 push	 0
  0001f	6a 01		 push	 1
  00021	e8 00 00 00 00	 call	 _GDT_AddDescriptor
  00026	83 c4 10	 add	 esp, 16			; 00000010H

; 121  : 
; 122  : 
; 123  : 	//Add the data segment
; 124  : 	GDT_AddDescriptor(2, 0, 0x000FFFFF,
; 125  : 		 GDT_Flags_Type_ReadWrite	//Writable data segment
; 126  : 		|GDT_Flags_CodeORData		//Not system segment
; 127  : 		|GDT_Flags_Present			//Present segment
; 128  : 		|GDT_Flags_DB32Bit			//32bit segment
; 129  : 		|GDT_Flags_Granularity4GB);	//Up to 4GiB segement

  00029	68 92 c0 00 00	 push	 49298			; 0000c092H
  0002e	68 ff ff 0f 00	 push	 1048575			; 000fffffH
  00033	6a 00		 push	 0
  00035	6a 02		 push	 2
  00037	e8 00 00 00 00	 call	 _GDT_AddDescriptor
  0003c	83 c4 10	 add	 esp, 16			; 00000010H

; 130  : 	
; 131  : 
; 132  : 	//Setting up the GDTR
; 133  : 	GDTR.GDT_Base	=	(uint32) &GDT[0];

  0003f	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _GDTR+2, OFFSET _GDT

; 134  : 	GDTR.GDT_Limit	=	(uint16) ((sizeof(struct GDT_Descriptor) * GDT_Size) -1);

  00049	b8 17 00 00 00	 mov	 eax, 23			; 00000017H
  0004e	66 a3 00 00 00
	00		 mov	 WORD PTR _GDTR, ax

; 135  : 
; 136  : 
; 137  : 	//Loading the GDTR
; 138  : 	GDT_GdtrSetup();

  00054	e8 00 00 00 00	 call	 _GDT_GdtrSetup

; 139  : 
; 140  : }

  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_GDT_Setup ENDP
; Function compile flags: /Odtpy
_GDT_GdtrSetup PROC

; 63   : {

  00060	55		 push	 ebp
  00061	8b ec		 mov	 ebp, esp

; 64   : 
; 65   : #ifdef _MSC_VER	//This works for visual studio only
; 66   : 
; 67   : 	_asm lgdt	[GDTR]

  00063	0f 01 15 00 00
	00 00		 lgdt	 FWORD PTR _GDTR

; 68   : 
; 69   : #endif
; 70   : 
; 71   : }

  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
_GDT_GdtrSetup ENDP
_TEXT	ENDS
EXTRN	_memset:PROC
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_Desc_Index$ = 8					; size = 1
_Desc_Base$ = 12					; size = 4
_Desc_Limit$ = 16					; size = 4
_Desc_Flags$ = 20					; size = 2
_GDT_AddDescriptor PROC

; 77   : {

  00070	55		 push	 ebp
  00071	8b ec		 mov	 ebp, esp

; 78   : 	
; 79   : 	//checking for limit of GDT
; 80   : 	if (Desc_Index >= GDT_Size) return;

  00073	0f b6 45 08	 movzx	 eax, BYTE PTR _Desc_Index$[ebp]
  00077	83 f8 03	 cmp	 eax, 3
  0007a	7c 05		 jl	 SHORT $LN1@GDT_AddDes
  0007c	e9 8e 00 00 00	 jmp	 $LN2@GDT_AddDes
$LN1@GDT_AddDes:

; 81   : 
; 82   : 	//zeroing	the descriptor!!
; 83   : 	memset((void*) &GDT[Desc_Index], 0, (size_t) sizeof(GDT[Desc_Index]));

  00081	6a 08		 push	 8
  00083	6a 00		 push	 0
  00085	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Desc_Index$[ebp]
  00089	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR _GDT[ecx*8]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 _memset
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 84   : 
; 85   : 	//setting descriptor fields
; 86   : 	GDT[Desc_Index].BaseLS	=	(uint16)  (Desc_Base		& 0xFFFF	);

  00099	8b 45 0c	 mov	 eax, DWORD PTR _Desc_Base$[ebp]
  0009c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000a1	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Desc_Index$[ebp]
  000a5	66 89 04 cd 02
	00 00 00	 mov	 WORD PTR _GDT[ecx*8+2], ax

; 87   : 	GDT[Desc_Index].BaseDS	=	(uint8)   ((Desc_Base >> 16)	& 0xFF	);

  000ad	8b 55 0c	 mov	 edx, DWORD PTR _Desc_Base$[ebp]
  000b0	c1 ea 10	 shr	 edx, 16			; 00000010H
  000b3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  000b9	0f b6 45 08	 movzx	 eax, BYTE PTR _Desc_Index$[ebp]
  000bd	88 14 c5 04 00
	00 00		 mov	 BYTE PTR _GDT[eax*8+4], dl

; 88   : 	GDT[Desc_Index].BaseMS	=	(uint8)   ((Desc_Base >> 24)	& 0xFF	);

  000c4	8b 4d 0c	 mov	 ecx, DWORD PTR _Desc_Base$[ebp]
  000c7	c1 e9 18	 shr	 ecx, 24			; 00000018H
  000ca	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  000d0	0f b6 55 08	 movzx	 edx, BYTE PTR _Desc_Index$[ebp]
  000d4	88 0c d5 07 00
	00 00		 mov	 BYTE PTR _GDT[edx*8+7], cl

; 89   : 	GDT[Desc_Index].LimitLS	=	(uint16)  ((Desc_Limit)		& 0xFFFF	);

  000db	8b 45 10	 mov	 eax, DWORD PTR _Desc_Limit$[ebp]
  000de	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  000e3	0f b6 4d 08	 movzx	 ecx, BYTE PTR _Desc_Index$[ebp]
  000e7	66 89 04 cd 00
	00 00 00	 mov	 WORD PTR _GDT[ecx*8], ax

; 90   : 	GDT[Desc_Index].Flags	=	(Desc_Flags | (uint16) GDT_Flags_Limit(Desc_Limit));

  000ef	0f b7 55 14	 movzx	 edx, WORD PTR _Desc_Flags$[ebp]
  000f3	8b 45 10	 mov	 eax, DWORD PTR _Desc_Limit$[ebp]
  000f6	c1 e8 08	 shr	 eax, 8
  000f9	25 00 0f 00 00	 and	 eax, 3840		; 00000f00H
  000fe	0f b7 c8	 movzx	 ecx, ax
  00101	0b d1		 or	 edx, ecx
  00103	0f b6 45 08	 movzx	 eax, BYTE PTR _Desc_Index$[ebp]
  00107	66 89 14 c5 05
	00 00 00	 mov	 WORD PTR _GDT[eax*8+5], dx
$LN2@GDT_AddDes:

; 91   : 	
; 92   : }

  0010f	5d		 pop	 ebp
  00110	c3		 ret	 0
_GDT_AddDescriptor ENDP
_TEXT	ENDS
END
