; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\GRAD\EOS - (KB)\EOSKernel32\Architecture dependent\IA32\IDT.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG1061	DB	' Alhamdo Le ALLAH ............................... :D :D '
	DB	':D ', 00H
$SG1065	DB	' Divide by zero Exception ', 00H
	ORG $+1
$SG1069	DB	' Debug Exception ', 00H
	ORG $+2
$SG1073	DB	' NMI Exception', 00H
	ORG $+1
$SG1077	DB	' Break Point Exception', 00H
	ORG $+1
$SG1081	DB	' OverFlow Exception', 00H
$SG1085	DB	' Bound Exception', 00H
	ORG $+3
$SG1089	DB	' Invalid OPCode Exception', 00H
	ORG $+2
$SG1093	DB	' Math co processor does  not exist Exception', 00H
	ORG $+3
$SG1097	DB	' Double Fault Exception', 00H
$SG1101	DB	' Coprocessor overrun Exception', 00H
	ORG $+1
$SG1105	DB	' Invalid TSS Exception', 00H
	ORG $+1
$SG1109	DB	' SegmentNotPresent Exception', 00H
	ORG $+3
$SG1113	DB	' Stack segment fault Exception', 00H
	ORG $+1
$SG1117	DB	' General Protection Exception', 00H
	ORG $+2
$SG1121	DB	' Page fault Exception', 00H
	ORG $+2
$SG1125	DB	' Float point error Exception', 00H
	ORG $+3
$SG1129	DB	' Allignment check Exception', 00H
$SG1133	DB	' Machine check Exception', 00H
	ORG $+3
$SG1137	DB	' SIMD Exception', 00H
_DATA	ENDS
PUBLIC	_IDT_AddHandler
EXTRN	_memset:PROC
_BSS	SEGMENT
_IDT	DQ	0100H DUP (?)
; Function compile flags: /Odtpy
; File d:\grad\eos - (kb)\eoskernel32\architecture dependent\ia32\idt.c
_BSS	ENDS
_TEXT	SEGMENT
_IntHandler_Index$ = 8					; size = 2
_IntHandler_Offset$ = 12				; size = 4
_IntHandler_Selector$ = 16				; size = 2
_IntHandler_Flags$ = 20					; size = 1
_IDT_AddHandler PROC

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : 	
; 77   : 	//check that Handling function pointer is not NULL (i.e. =0) nor index is above max value of interrupts
; 78   : 	if ((IntHandler_Index >= (uint16)IDT_Size) || (!IntHandler_Offset)) return;

  00003	0f b7 45 08	 movzx	 eax, WORD PTR _IntHandler_Index$[ebp]
  00007	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0000c	7d 06		 jge	 SHORT $LN1@IDT_AddHan
  0000e	83 7d 0c 00	 cmp	 DWORD PTR _IntHandler_Offset$[ebp], 0
  00012	75 02		 jne	 SHORT $LN2@IDT_AddHan
$LN1@IDT_AddHan:
  00014	eb 6f		 jmp	 SHORT $LN3@IDT_AddHan
$LN2@IDT_AddHan:

; 79   : 
; 80   : 
; 81   : 	//Zeroing the interrupt descriptor first
; 82   : 	memset((void*) &IDT[IntHandler_Index], 0, (size_t) sizeof(IDT[IntHandler_Index]));

  00016	6a 08		 push	 8
  00018	6a 00		 push	 0
  0001a	0f b7 4d 08	 movzx	 ecx, WORD PTR _IntHandler_Index$[ebp]
  0001e	8d 14 cd 00 00
	00 00		 lea	 edx, DWORD PTR _IDT[ecx*8]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 _memset
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 83   : 
; 84   : 
; 85   : 	//Assigning values to our interrupt descriptor
; 86   : 	IDT[IntHandler_Index].IDT_Reserved		=	0x0;

  0002e	0f b7 45 08	 movzx	 eax, WORD PTR _IntHandler_Index$[ebp]
  00032	c6 04 c5 04 00
	00 00 00	 mov	 BYTE PTR _IDT[eax*8+4], 0

; 87   : 	IDT[IntHandler_Index].IDT_Selector		=	IntHandler_Selector;

  0003a	0f b7 4d 08	 movzx	 ecx, WORD PTR _IntHandler_Index$[ebp]
  0003e	66 8b 55 10	 mov	 dx, WORD PTR _IntHandler_Selector$[ebp]
  00042	66 89 14 cd 02
	00 00 00	 mov	 WORD PTR _IDT[ecx*8+2], dx

; 88   : 	IDT[IntHandler_Index].IDT_Flags		=	IntHandler_Flags;

  0004a	0f b7 45 08	 movzx	 eax, WORD PTR _IntHandler_Index$[ebp]
  0004e	8a 4d 14	 mov	 cl, BYTE PTR _IntHandler_Flags$[ebp]
  00051	88 0c c5 05 00
	00 00		 mov	 BYTE PTR _IDT[eax*8+5], cl

; 89   : 	IDT[IntHandler_Index].IDT_OffsetLS		=	(uint16)(IntHandler_Offset & 0xFFFF);		

  00058	8b 55 0c	 mov	 edx, DWORD PTR _IntHandler_Offset$[ebp]
  0005b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00061	0f b7 45 08	 movzx	 eax, WORD PTR _IntHandler_Index$[ebp]
  00065	66 89 14 c5 00
	00 00 00	 mov	 WORD PTR _IDT[eax*8], dx

; 90   : 	IDT[IntHandler_Index].IDT_OffsetMS		=	(uint16)((IntHandler_Offset >> 16) & 0xFFFF);

  0006d	8b 4d 0c	 mov	 ecx, DWORD PTR _IntHandler_Offset$[ebp]
  00070	c1 e9 10	 shr	 ecx, 16			; 00000010H
  00073	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00079	0f b7 55 08	 movzx	 edx, WORD PTR _IntHandler_Index$[ebp]
  0007d	66 89 0c d5 06
	00 00 00	 mov	 WORD PTR _IDT[edx*8+6], cx
$LN3@IDT_AddHan:

; 91   : 	return;
; 92   : 
; 93   : }

  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_IDT_AddHandler ENDP
_TEXT	ENDS
PUBLIC	_IDT_DefaultHandler
EXTRN	_EOS_PrintString:PROC
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_IDT_DefaultHandler PROC

; 102  : 	_asm pushad

  00090	60		 pushad

; 103  : 
; 104  : 	EOS_PrintString(" Alhamdo Le ALLAH ............................... :D :D :D ",0x46, 0x2, 4);	

  00091	6a 04		 push	 4
  00093	6a 02		 push	 2
  00095	6a 46		 push	 70			; 00000046H
  00097	68 00 00 00 00	 push	 OFFSET $SG1061
  0009c	e8 00 00 00 00	 call	 _EOS_PrintString
  000a1	83 c4 10	 add	 esp, 16			; 00000010H

; 105  : 	
; 106  : 	_asm popad

  000a4	61		 popad

; 107  : 	_asm iretd

  000a5	cf		 iretd
_IDT_DefaultHandler ENDP
_TEXT	ENDS
PUBLIC	_ZeroException
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_ZeroException PROC

; 116  : 	_asm pushad

  000b0	60		 pushad

; 117  : 
; 118  : 	EOS_PrintString(" Divide by zero Exception ",0x46, 0x2, 4);	

  000b1	6a 04		 push	 4
  000b3	6a 02		 push	 2
  000b5	6a 46		 push	 70			; 00000046H
  000b7	68 00 00 00 00	 push	 OFFSET $SG1065
  000bc	e8 00 00 00 00	 call	 _EOS_PrintString
  000c1	83 c4 10	 add	 esp, 16			; 00000010H

; 119  : 	
; 120  : 	_asm popad

  000c4	61		 popad

; 121  : 	_asm iretd

  000c5	cf		 iretd
_ZeroException ENDP
_TEXT	ENDS
PUBLIC	_Debug
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_Debug	PROC

; 126  : 	_asm pushad

  000d0	60		 pushad

; 127  : 
; 128  : 	EOS_PrintString(" Debug Exception ",0x46, 0x2, 4);	

  000d1	6a 04		 push	 4
  000d3	6a 02		 push	 2
  000d5	6a 46		 push	 70			; 00000046H
  000d7	68 00 00 00 00	 push	 OFFSET $SG1069
  000dc	e8 00 00 00 00	 call	 _EOS_PrintString
  000e1	83 c4 10	 add	 esp, 16			; 00000010H

; 129  : 	
; 130  : 	_asm popad

  000e4	61		 popad

; 131  : 	_asm iretd

  000e5	cf		 iretd
_Debug	ENDP
_TEXT	ENDS
PUBLIC	_NMI
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_NMI	PROC

; 137  : 	_asm pushad

  000f0	60		 pushad

; 138  : 
; 139  : 	EOS_PrintString(" NMI Exception",0x46, 0x2, 4);	

  000f1	6a 04		 push	 4
  000f3	6a 02		 push	 2
  000f5	6a 46		 push	 70			; 00000046H
  000f7	68 00 00 00 00	 push	 OFFSET $SG1073
  000fc	e8 00 00 00 00	 call	 _EOS_PrintString
  00101	83 c4 10	 add	 esp, 16			; 00000010H

; 140  : 	
; 141  : 	_asm popad

  00104	61		 popad

; 142  : 	_asm iretd

  00105	cf		 iretd
_NMI	ENDP
_TEXT	ENDS
PUBLIC	_BreakPoint
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_BreakPoint PROC

; 150  : 	_asm pushad

  00110	60		 pushad

; 151  : 
; 152  : 	EOS_PrintString(" Break Point Exception",0x46, 0x2, 4);	

  00111	6a 04		 push	 4
  00113	6a 02		 push	 2
  00115	6a 46		 push	 70			; 00000046H
  00117	68 00 00 00 00	 push	 OFFSET $SG1077
  0011c	e8 00 00 00 00	 call	 _EOS_PrintString
  00121	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 	
; 154  : 	_asm popad

  00124	61		 popad

; 155  : 	_asm iretd

  00125	cf		 iretd
_BreakPoint ENDP
_TEXT	ENDS
PUBLIC	_OverFlow
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_OverFlow PROC

; 164  : 	_asm pushad

  00130	60		 pushad

; 165  : 
; 166  : 	EOS_PrintString(" OverFlow Exception",0x46, 0x2, 4);	

  00131	6a 04		 push	 4
  00133	6a 02		 push	 2
  00135	6a 46		 push	 70			; 00000046H
  00137	68 00 00 00 00	 push	 OFFSET $SG1081
  0013c	e8 00 00 00 00	 call	 _EOS_PrintString
  00141	83 c4 10	 add	 esp, 16			; 00000010H

; 167  : 	
; 168  : 	_asm popad

  00144	61		 popad

; 169  : 	_asm iretd

  00145	cf		 iretd
_OverFlow ENDP
_TEXT	ENDS
PUBLIC	_Bound
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_Bound	PROC

; 175  : 	_asm pushad

  00150	60		 pushad

; 176  : 
; 177  : 	EOS_PrintString(" Bound Exception",0x46, 0x2, 4);	

  00151	6a 04		 push	 4
  00153	6a 02		 push	 2
  00155	6a 46		 push	 70			; 00000046H
  00157	68 00 00 00 00	 push	 OFFSET $SG1085
  0015c	e8 00 00 00 00	 call	 _EOS_PrintString
  00161	83 c4 10	 add	 esp, 16			; 00000010H

; 178  : 	
; 179  : 	_asm popad

  00164	61		 popad

; 180  : 	_asm iretd

  00165	cf		 iretd
_Bound	ENDP
_TEXT	ENDS
PUBLIC	_InvalidOpcode
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_InvalidOpcode PROC

; 186  : 	_asm pushad

  00170	60		 pushad

; 187  : 
; 188  : 	EOS_PrintString(" Invalid OPCode Exception",0x46, 0x2, 4);	

  00171	6a 04		 push	 4
  00173	6a 02		 push	 2
  00175	6a 46		 push	 70			; 00000046H
  00177	68 00 00 00 00	 push	 OFFSET $SG1089
  0017c	e8 00 00 00 00	 call	 _EOS_PrintString
  00181	83 c4 10	 add	 esp, 16			; 00000010H

; 189  : 	
; 190  : 	_asm popad

  00184	61		 popad

; 191  : 	_asm iretd

  00185	cf		 iretd
_InvalidOpcode ENDP
_TEXT	ENDS
PUBLIC	_MathCo
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_MathCo	PROC

; 197  : 	_asm pushad

  00190	60		 pushad

; 198  : 
; 199  : 	EOS_PrintString(" Math co processor does  not exist Exception",0x46, 0x2, 4);	

  00191	6a 04		 push	 4
  00193	6a 02		 push	 2
  00195	6a 46		 push	 70			; 00000046H
  00197	68 00 00 00 00	 push	 OFFSET $SG1093
  0019c	e8 00 00 00 00	 call	 _EOS_PrintString
  001a1	83 c4 10	 add	 esp, 16			; 00000010H

; 200  : 	
; 201  : 	_asm popad

  001a4	61		 popad

; 202  : 	_asm iretd

  001a5	cf		 iretd
_MathCo	ENDP
_TEXT	ENDS
PUBLIC	_DoubleFault
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_DoubleFault PROC

; 209  : 	_asm add esp, 4

  001b0	83 c4 04	 add	 esp, 4

; 210  : 	_asm pushad

  001b3	60		 pushad

; 211  : 
; 212  : 	EOS_PrintString(" Double Fault Exception",0x46, 0x2, 4);	

  001b4	6a 04		 push	 4
  001b6	6a 02		 push	 2
  001b8	6a 46		 push	 70			; 00000046H
  001ba	68 00 00 00 00	 push	 OFFSET $SG1097
  001bf	e8 00 00 00 00	 call	 _EOS_PrintString
  001c4	83 c4 10	 add	 esp, 16			; 00000010H

; 213  : 	
; 214  : 	_asm popad

  001c7	61		 popad

; 215  : 	_asm iretd

  001c8	cf		 iretd
_DoubleFault ENDP
_TEXT	ENDS
PUBLIC	_CoprocessorOverrun
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_CoprocessorOverrun PROC

; 222  : 	_asm pushad

  001d0	60		 pushad

; 223  : 
; 224  : 	EOS_PrintString(" Coprocessor overrun Exception",0x46, 0x2, 4);	

  001d1	6a 04		 push	 4
  001d3	6a 02		 push	 2
  001d5	6a 46		 push	 70			; 00000046H
  001d7	68 00 00 00 00	 push	 OFFSET $SG1101
  001dc	e8 00 00 00 00	 call	 _EOS_PrintString
  001e1	83 c4 10	 add	 esp, 16			; 00000010H

; 225  : 	
; 226  : 	_asm popad

  001e4	61		 popad

; 227  : 	_asm iretd

  001e5	cf		 iretd
_CoprocessorOverrun ENDP
_TEXT	ENDS
PUBLIC	_InvalidTSS
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_InvalidTSS PROC

; 233  : 	_asm add esp, 4

  001f0	83 c4 04	 add	 esp, 4

; 234  : 	_asm pushad

  001f3	60		 pushad

; 235  : 
; 236  : 	EOS_PrintString(" Invalid TSS Exception",0x46, 0x2, 4);	

  001f4	6a 04		 push	 4
  001f6	6a 02		 push	 2
  001f8	6a 46		 push	 70			; 00000046H
  001fa	68 00 00 00 00	 push	 OFFSET $SG1105
  001ff	e8 00 00 00 00	 call	 _EOS_PrintString
  00204	83 c4 10	 add	 esp, 16			; 00000010H

; 237  : 	
; 238  : 	_asm popad

  00207	61		 popad

; 239  : 	_asm iretd

  00208	cf		 iretd
_InvalidTSS ENDP
_TEXT	ENDS
PUBLIC	_SegmentNotPresent
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_SegmentNotPresent PROC

; 246  : 	_asm add esp, 4

  00210	83 c4 04	 add	 esp, 4

; 247  : 	_asm pushad

  00213	60		 pushad

; 248  : 
; 249  : 	EOS_PrintString(" SegmentNotPresent Exception",0x46, 0x2, 4);	

  00214	6a 04		 push	 4
  00216	6a 02		 push	 2
  00218	6a 46		 push	 70			; 00000046H
  0021a	68 00 00 00 00	 push	 OFFSET $SG1109
  0021f	e8 00 00 00 00	 call	 _EOS_PrintString
  00224	83 c4 10	 add	 esp, 16			; 00000010H

; 250  : 	
; 251  : 	_asm popad

  00227	61		 popad

; 252  : 	_asm iretd

  00228	cf		 iretd
_SegmentNotPresent ENDP
_TEXT	ENDS
PUBLIC	_StackSegmentFault
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_StackSegmentFault PROC

; 260  : 	_asm add esp, 4

  00230	83 c4 04	 add	 esp, 4

; 261  : 	_asm pushad

  00233	60		 pushad

; 262  : 
; 263  : 	EOS_PrintString(" Stack segment fault Exception",0x46, 0x2, 4);	

  00234	6a 04		 push	 4
  00236	6a 02		 push	 2
  00238	6a 46		 push	 70			; 00000046H
  0023a	68 00 00 00 00	 push	 OFFSET $SG1113
  0023f	e8 00 00 00 00	 call	 _EOS_PrintString
  00244	83 c4 10	 add	 esp, 16			; 00000010H

; 264  : 	
; 265  : 	_asm popad

  00247	61		 popad

; 266  : 	_asm iretd

  00248	cf		 iretd
_StackSegmentFault ENDP
_TEXT	ENDS
PUBLIC	_GeneralProtection
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_GeneralProtection PROC

; 272  : 	_asm add esp, 4

  00250	83 c4 04	 add	 esp, 4

; 273  : 	_asm pushad

  00253	60		 pushad

; 274  : 
; 275  : 	EOS_PrintString(" General Protection Exception",0x46, 0x2, 4);	

  00254	6a 04		 push	 4
  00256	6a 02		 push	 2
  00258	6a 46		 push	 70			; 00000046H
  0025a	68 00 00 00 00	 push	 OFFSET $SG1117
  0025f	e8 00 00 00 00	 call	 _EOS_PrintString
  00264	83 c4 10	 add	 esp, 16			; 00000010H

; 276  : 	
; 277  : 	_asm popad

  00267	61		 popad

; 278  : 	_asm iretd

  00268	cf		 iretd
_GeneralProtection ENDP
_TEXT	ENDS
PUBLIC	_PageFault
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_PageFault PROC

; 285  : 	_asm add esp, 4

  00270	83 c4 04	 add	 esp, 4

; 286  : 	_asm pushad

  00273	60		 pushad

; 287  : 
; 288  : 	EOS_PrintString(" Page fault Exception",0x46, 0x2, 4);	

  00274	6a 04		 push	 4
  00276	6a 02		 push	 2
  00278	6a 46		 push	 70			; 00000046H
  0027a	68 00 00 00 00	 push	 OFFSET $SG1121
  0027f	e8 00 00 00 00	 call	 _EOS_PrintString
  00284	83 c4 10	 add	 esp, 16			; 00000010H

; 289  : 	
; 290  : 	_asm popad

  00287	61		 popad

; 291  : 	_asm iretd

  00288	cf		 iretd
_PageFault ENDP
_TEXT	ENDS
PUBLIC	_FloatError
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_FloatError PROC

; 297  : 	_asm pushad

  00290	60		 pushad

; 298  : 
; 299  : 	EOS_PrintString(" Float point error Exception",0x46, 0x2, 4);	

  00291	6a 04		 push	 4
  00293	6a 02		 push	 2
  00295	6a 46		 push	 70			; 00000046H
  00297	68 00 00 00 00	 push	 OFFSET $SG1125
  0029c	e8 00 00 00 00	 call	 _EOS_PrintString
  002a1	83 c4 10	 add	 esp, 16			; 00000010H

; 300  : 	
; 301  : 	_asm popad

  002a4	61		 popad

; 302  : 	_asm iretd

  002a5	cf		 iretd
_FloatError ENDP
_TEXT	ENDS
PUBLIC	_Allignment
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_Allignment PROC

; 309  : 	_asm add esp, 4

  002b0	83 c4 04	 add	 esp, 4

; 310  : 	_asm pushad

  002b3	60		 pushad

; 311  : 
; 312  : 	EOS_PrintString(" Allignment check Exception",0x46, 0x2, 4);	

  002b4	6a 04		 push	 4
  002b6	6a 02		 push	 2
  002b8	6a 46		 push	 70			; 00000046H
  002ba	68 00 00 00 00	 push	 OFFSET $SG1129
  002bf	e8 00 00 00 00	 call	 _EOS_PrintString
  002c4	83 c4 10	 add	 esp, 16			; 00000010H

; 313  : 	
; 314  : 	_asm popad

  002c7	61		 popad

; 315  : 	_asm iretd

  002c8	cf		 iretd
_Allignment ENDP
_TEXT	ENDS
PUBLIC	_MachineCheck
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_MachineCheck PROC

; 321  : 	_asm pushad

  002d0	60		 pushad

; 322  : 
; 323  : 	EOS_PrintString(" Machine check Exception",0x46, 0x2, 4);	

  002d1	6a 04		 push	 4
  002d3	6a 02		 push	 2
  002d5	6a 46		 push	 70			; 00000046H
  002d7	68 00 00 00 00	 push	 OFFSET $SG1133
  002dc	e8 00 00 00 00	 call	 _EOS_PrintString
  002e1	83 c4 10	 add	 esp, 16			; 00000010H

; 324  : 	
; 325  : 	_asm popad

  002e4	61		 popad

; 326  : 	_asm iretd

  002e5	cf		 iretd
_MachineCheck ENDP
_TEXT	ENDS
PUBLIC	_SIMD
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_SIMD	PROC

; 332  : 	_asm pushad

  002f0	60		 pushad

; 333  : 
; 334  : 	EOS_PrintString(" SIMD Exception",0x46, 0x2, 4);	

  002f1	6a 04		 push	 4
  002f3	6a 02		 push	 2
  002f5	6a 46		 push	 70			; 00000046H
  002f7	68 00 00 00 00	 push	 OFFSET $SG1137
  002fc	e8 00 00 00 00	 call	 _EOS_PrintString
  00301	83 c4 10	 add	 esp, 16			; 00000010H

; 335  : 	
; 336  : 	_asm popad

  00304	61		 popad

; 337  : 	_asm iretd

  00305	cf		 iretd
_SIMD	ENDP
_TEXT	ENDS
PUBLIC	_INT_Fn
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_n$ = 8							; size = 1
_INT_Fn	PROC

; 359  : {

  00310	55		 push	 ebp
  00311	8b ec		 mov	 ebp, esp

; 360  : 
; 361  : #ifdef _MSC_VER
; 362  : 
; 363  : 	_asm
; 364  : 	{
; 365  : 		mov al, [n]

  00313	8a 45 08	 mov	 al, BYTE PTR _n$[ebp]

; 366  : 		mov byte ptr [INTR +1], al	//op code of INT = 1 byte then 1 byte for imm operand

  00316	88 05 01 00 00
	00		 mov	 OFFSET $INTR$1142+1, al

; 367  : 		jmp INTR

  0031c	eb 00		 jmp	 SHORT $INTR$1142
$INTR$1142:

; 368  : 	INTR:
; 369  : 		INT 0

  0031e	cd 00		 int	 0

; 370  : 	}
; 371  : 	
; 372  : #endif
; 373  : 
; 374  : }

  00320	5d		 pop	 ebp
  00321	c3		 ret	 0
_INT_Fn	ENDP
_TEXT	ENDS
PUBLIC	_IDT_Setup
_BSS	SEGMENT
_IDTR	DF	01H DUP (?)
; Function compile flags: /Odtpy
_BSS	ENDS
_TEXT	SEGMENT
_i$ = -4						; size = 2
_IDT_Setup PROC

; 382  : {

  00330	55		 push	 ebp
  00331	8b ec		 mov	 ebp, esp
  00333	51		 push	 ecx

; 383  : 	
; 384  : 	uint16 i;
; 385  : 
; 386  : 		
; 387  : 	//Add default handler for all our 256 handling routines
; 388  : 	for (i =0; i<(uint16)IDT_Size; i++) 

  00334	33 c0		 xor	 eax, eax
  00336	66 89 45 fc	 mov	 WORD PTR _i$[ebp], ax
  0033a	eb 0c		 jmp	 SHORT $LN3@IDT_Setup
$LN2@IDT_Setup:
  0033c	66 8b 4d fc	 mov	 cx, WORD PTR _i$[ebp]
  00340	66 83 c1 01	 add	 cx, 1
  00344	66 89 4d fc	 mov	 WORD PTR _i$[ebp], cx
$LN3@IDT_Setup:
  00348	0f b7 55 fc	 movzx	 edx, WORD PTR _i$[ebp]
  0034c	81 fa 00 01 00
	00		 cmp	 edx, 256		; 00000100H
  00352	7d 1b		 jge	 SHORT $LN1@IDT_Setup

; 389  : 		IDT_AddHandler(i, (uint32) &IDT_DefaultHandler, 0x8,
; 390  : 		 IDT_Flags_32Bit
; 391  : 		|IDT_Flags_Default
; 392  : 		|IDT_Flags_Present);

  00354	68 8e 00 00 00	 push	 142			; 0000008eH
  00359	6a 08		 push	 8
  0035b	68 00 00 00 00	 push	 OFFSET _IDT_DefaultHandler
  00360	0f b7 45 fc	 movzx	 eax, WORD PTR _i$[ebp]
  00364	50		 push	 eax
  00365	e8 00 00 00 00	 call	 _IDT_AddHandler
  0036a	83 c4 10	 add	 esp, 16			; 00000010H
  0036d	eb cd		 jmp	 SHORT $LN2@IDT_Setup
$LN1@IDT_Setup:

; 393  : 
; 394  : 
; 395  : 	IDT_AddHandler(0, (uint32) &ZeroException, 0x8,
; 396  : 		 IDT_Flags_32Bit
; 397  : 		|IDT_Flags_Default
; 398  : 		|IDT_Flags_Present);

  0036f	68 8e 00 00 00	 push	 142			; 0000008eH
  00374	6a 08		 push	 8
  00376	68 00 00 00 00	 push	 OFFSET _ZeroException
  0037b	6a 00		 push	 0
  0037d	e8 00 00 00 00	 call	 _IDT_AddHandler
  00382	83 c4 10	 add	 esp, 16			; 00000010H

; 399  : 
; 400  : 	IDT_AddHandler(1, (uint32) &Debug, 0x8,
; 401  : 		 IDT_Flags_32Bit
; 402  : 		|IDT_Flags_Default
; 403  : 		|IDT_Flags_Present);

  00385	68 8e 00 00 00	 push	 142			; 0000008eH
  0038a	6a 08		 push	 8
  0038c	68 00 00 00 00	 push	 OFFSET _Debug
  00391	6a 01		 push	 1
  00393	e8 00 00 00 00	 call	 _IDT_AddHandler
  00398	83 c4 10	 add	 esp, 16			; 00000010H

; 404  : 
; 405  : 	IDT_AddHandler(2, (uint32) &NMI, 0x8,
; 406  : 		 IDT_Flags_32Bit
; 407  : 		|IDT_Flags_Default
; 408  : 		|IDT_Flags_Present);

  0039b	68 8e 00 00 00	 push	 142			; 0000008eH
  003a0	6a 08		 push	 8
  003a2	68 00 00 00 00	 push	 OFFSET _NMI
  003a7	6a 02		 push	 2
  003a9	e8 00 00 00 00	 call	 _IDT_AddHandler
  003ae	83 c4 10	 add	 esp, 16			; 00000010H

; 409  : 
; 410  : 	IDT_AddHandler(3, (uint32) &BreakPoint, 0x8,
; 411  : 		 IDT_Flags_32Bit
; 412  : 		|IDT_Flags_Default
; 413  : 		|IDT_Flags_Present);

  003b1	68 8e 00 00 00	 push	 142			; 0000008eH
  003b6	6a 08		 push	 8
  003b8	68 00 00 00 00	 push	 OFFSET _BreakPoint
  003bd	6a 03		 push	 3
  003bf	e8 00 00 00 00	 call	 _IDT_AddHandler
  003c4	83 c4 10	 add	 esp, 16			; 00000010H

; 414  : 
; 415  : 	IDT_AddHandler(4, (uint32) &OverFlow, 0x8,
; 416  : 		 IDT_Flags_32Bit
; 417  : 		|IDT_Flags_Default
; 418  : 		|IDT_Flags_Present);

  003c7	68 8e 00 00 00	 push	 142			; 0000008eH
  003cc	6a 08		 push	 8
  003ce	68 00 00 00 00	 push	 OFFSET _OverFlow
  003d3	6a 04		 push	 4
  003d5	e8 00 00 00 00	 call	 _IDT_AddHandler
  003da	83 c4 10	 add	 esp, 16			; 00000010H

; 419  : 
; 420  : 	IDT_AddHandler(5, (uint32) &Bound, 0x8,
; 421  : 		 IDT_Flags_32Bit
; 422  : 		|IDT_Flags_Default
; 423  : 		|IDT_Flags_Present);

  003dd	68 8e 00 00 00	 push	 142			; 0000008eH
  003e2	6a 08		 push	 8
  003e4	68 00 00 00 00	 push	 OFFSET _Bound
  003e9	6a 05		 push	 5
  003eb	e8 00 00 00 00	 call	 _IDT_AddHandler
  003f0	83 c4 10	 add	 esp, 16			; 00000010H

; 424  : 
; 425  : 	IDT_AddHandler(6, (uint32) &InvalidOpcode, 0x8,
; 426  : 		 IDT_Flags_32Bit
; 427  : 		|IDT_Flags_Default
; 428  : 		|IDT_Flags_Present);

  003f3	68 8e 00 00 00	 push	 142			; 0000008eH
  003f8	6a 08		 push	 8
  003fa	68 00 00 00 00	 push	 OFFSET _InvalidOpcode
  003ff	6a 06		 push	 6
  00401	e8 00 00 00 00	 call	 _IDT_AddHandler
  00406	83 c4 10	 add	 esp, 16			; 00000010H

; 429  : 
; 430  : 	IDT_AddHandler(7, (uint32) &MathCo, 0x8,
; 431  : 		 IDT_Flags_32Bit
; 432  : 		|IDT_Flags_Default
; 433  : 		|IDT_Flags_Present);

  00409	68 8e 00 00 00	 push	 142			; 0000008eH
  0040e	6a 08		 push	 8
  00410	68 00 00 00 00	 push	 OFFSET _MathCo
  00415	6a 07		 push	 7
  00417	e8 00 00 00 00	 call	 _IDT_AddHandler
  0041c	83 c4 10	 add	 esp, 16			; 00000010H

; 434  : 
; 435  : 	IDT_AddHandler(8, (uint32) &DoubleFault, 0x8,
; 436  : 		 IDT_Flags_32Bit
; 437  : 		|IDT_Flags_Default
; 438  : 		|IDT_Flags_Present);

  0041f	68 8e 00 00 00	 push	 142			; 0000008eH
  00424	6a 08		 push	 8
  00426	68 00 00 00 00	 push	 OFFSET _DoubleFault
  0042b	6a 08		 push	 8
  0042d	e8 00 00 00 00	 call	 _IDT_AddHandler
  00432	83 c4 10	 add	 esp, 16			; 00000010H

; 439  : 
; 440  : 	IDT_AddHandler(9, (uint32) &CoprocessorOverrun, 0x8,
; 441  : 		 IDT_Flags_32Bit
; 442  : 		|IDT_Flags_Default
; 443  : 		|IDT_Flags_Present);

  00435	68 8e 00 00 00	 push	 142			; 0000008eH
  0043a	6a 08		 push	 8
  0043c	68 00 00 00 00	 push	 OFFSET _CoprocessorOverrun
  00441	6a 09		 push	 9
  00443	e8 00 00 00 00	 call	 _IDT_AddHandler
  00448	83 c4 10	 add	 esp, 16			; 00000010H

; 444  : 
; 445  : 	IDT_AddHandler(10, (uint32) &InvalidTSS, 0x8,
; 446  : 		 IDT_Flags_32Bit
; 447  : 		|IDT_Flags_Default
; 448  : 		|IDT_Flags_Present);

  0044b	68 8e 00 00 00	 push	 142			; 0000008eH
  00450	6a 08		 push	 8
  00452	68 00 00 00 00	 push	 OFFSET _InvalidTSS
  00457	6a 0a		 push	 10			; 0000000aH
  00459	e8 00 00 00 00	 call	 _IDT_AddHandler
  0045e	83 c4 10	 add	 esp, 16			; 00000010H

; 449  : 
; 450  : 	IDT_AddHandler(11, (uint32) &SegmentNotPresent, 0x8,
; 451  : 		 IDT_Flags_32Bit
; 452  : 		|IDT_Flags_Default
; 453  : 		|IDT_Flags_Present);

  00461	68 8e 00 00 00	 push	 142			; 0000008eH
  00466	6a 08		 push	 8
  00468	68 00 00 00 00	 push	 OFFSET _SegmentNotPresent
  0046d	6a 0b		 push	 11			; 0000000bH
  0046f	e8 00 00 00 00	 call	 _IDT_AddHandler
  00474	83 c4 10	 add	 esp, 16			; 00000010H

; 454  : 
; 455  : 	IDT_AddHandler(12, (uint32) &StackSegmentFault, 0x8,
; 456  : 		 IDT_Flags_32Bit
; 457  : 		|IDT_Flags_Default
; 458  : 		|IDT_Flags_Present);

  00477	68 8e 00 00 00	 push	 142			; 0000008eH
  0047c	6a 08		 push	 8
  0047e	68 00 00 00 00	 push	 OFFSET _StackSegmentFault
  00483	6a 0c		 push	 12			; 0000000cH
  00485	e8 00 00 00 00	 call	 _IDT_AddHandler
  0048a	83 c4 10	 add	 esp, 16			; 00000010H

; 459  : 
; 460  : 	IDT_AddHandler(13, (uint32) &GeneralProtection, 0x8,
; 461  : 		 IDT_Flags_32Bit
; 462  : 		|IDT_Flags_Default
; 463  : 		|IDT_Flags_Present);

  0048d	68 8e 00 00 00	 push	 142			; 0000008eH
  00492	6a 08		 push	 8
  00494	68 00 00 00 00	 push	 OFFSET _GeneralProtection
  00499	6a 0d		 push	 13			; 0000000dH
  0049b	e8 00 00 00 00	 call	 _IDT_AddHandler
  004a0	83 c4 10	 add	 esp, 16			; 00000010H

; 464  : 
; 465  : 	IDT_AddHandler(14, (uint32) &PageFault, 0x8,
; 466  : 		 IDT_Flags_32Bit
; 467  : 		|IDT_Flags_Default
; 468  : 		|IDT_Flags_Present);

  004a3	68 8e 00 00 00	 push	 142			; 0000008eH
  004a8	6a 08		 push	 8
  004aa	68 00 00 00 00	 push	 OFFSET _PageFault
  004af	6a 0e		 push	 14			; 0000000eH
  004b1	e8 00 00 00 00	 call	 _IDT_AddHandler
  004b6	83 c4 10	 add	 esp, 16			; 00000010H

; 469  : 
; 470  : 	IDT_AddHandler(16, (uint32) &FloatError, 0x8,
; 471  : 		 IDT_Flags_32Bit
; 472  : 		|IDT_Flags_Default
; 473  : 		|IDT_Flags_Present);

  004b9	68 8e 00 00 00	 push	 142			; 0000008eH
  004be	6a 08		 push	 8
  004c0	68 00 00 00 00	 push	 OFFSET _FloatError
  004c5	6a 10		 push	 16			; 00000010H
  004c7	e8 00 00 00 00	 call	 _IDT_AddHandler
  004cc	83 c4 10	 add	 esp, 16			; 00000010H

; 474  : 
; 475  : 	IDT_AddHandler(17, (uint32) &Allignment, 0x8,
; 476  : 		 IDT_Flags_32Bit
; 477  : 		|IDT_Flags_Default
; 478  : 		|IDT_Flags_Present);

  004cf	68 8e 00 00 00	 push	 142			; 0000008eH
  004d4	6a 08		 push	 8
  004d6	68 00 00 00 00	 push	 OFFSET _Allignment
  004db	6a 11		 push	 17			; 00000011H
  004dd	e8 00 00 00 00	 call	 _IDT_AddHandler
  004e2	83 c4 10	 add	 esp, 16			; 00000010H

; 479  : 
; 480  : 	IDT_AddHandler(18, (uint32) &MachineCheck, 0x8,
; 481  : 		 IDT_Flags_32Bit
; 482  : 		|IDT_Flags_Default
; 483  : 		|IDT_Flags_Present);

  004e5	68 8e 00 00 00	 push	 142			; 0000008eH
  004ea	6a 08		 push	 8
  004ec	68 00 00 00 00	 push	 OFFSET _MachineCheck
  004f1	6a 12		 push	 18			; 00000012H
  004f3	e8 00 00 00 00	 call	 _IDT_AddHandler
  004f8	83 c4 10	 add	 esp, 16			; 00000010H

; 484  : 
; 485  : 	IDT_AddHandler(19, (uint32) &SIMD, 0x8,
; 486  : 		 IDT_Flags_32Bit
; 487  : 		|IDT_Flags_Default
; 488  : 		|IDT_Flags_Present);

  004fb	68 8e 00 00 00	 push	 142			; 0000008eH
  00500	6a 08		 push	 8
  00502	68 00 00 00 00	 push	 OFFSET _SIMD
  00507	6a 13		 push	 19			; 00000013H
  00509	e8 00 00 00 00	 call	 _IDT_AddHandler
  0050e	83 c4 10	 add	 esp, 16			; 00000010H

; 489  : 
; 490  : 
; 491  : 	//Setting values of IDTR
; 492  : 	IDTR.IDT_Base	=	(uint32) &IDT[0];

  00511	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IDTR+2, OFFSET _IDT

; 493  : 	IDTR.IDT_Limit =	(uint16) (((sizeof(struct IDT_Descriptor)) * ((uint16)IDT_Size)) -1); 

  0051b	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00520	66 89 0d 00 00
	00 00		 mov	 WORD PTR _IDTR, cx

; 494  : 	//Limit of idt in bytes. we minus 1 as the first byte is base eitself->last byte = base + limit ;)
; 495  : 
; 496  : 
; 497  : 
; 498  : 
; 499  : 
; 500  : 	//Loading the IDTR
; 501  : 	IDT_IdtrSetup();

  00527	e8 00 00 00 00	 call	 _IDT_IdtrSetup

; 502  : 
; 503  : }

  0052c	8b e5		 mov	 esp, ebp
  0052e	5d		 pop	 ebp
  0052f	c3		 ret	 0
_IDT_Setup ENDP
; Function compile flags: /Odtpy
_IDT_IdtrSetup PROC

; 59   : {

  00530	55		 push	 ebp
  00531	8b ec		 mov	 ebp, esp

; 60   : 
; 61   : #ifdef _MSC_VER
; 62   : 
; 63   : 	_asm lidt [IDTR]

  00533	0f 01 1d 00 00
	00 00		 lidt	 FWORD PTR _IDTR

; 64   : 
; 65   : #endif
; 66   : 
; 67   : }

  0053a	5d		 pop	 ebp
  0053b	c3		 ret	 0
_IDT_IdtrSetup ENDP
_TEXT	ENDS
END
