; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.30319.01 

	TITLE	D:\GRAD\EOS - (KB)\EOSKernel32\Architecture dependent\IA32\PIC.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	_EnableIRQ
PUBLIC	_PIC_WriteData
PUBLIC	_PIC_SendCommand
PUBLIC	_PIC_Initialize
; Function compile flags: /Odtpy
; File d:\grad\eos - (kb)\eoskernel32\architecture dependent\ia32\pic.c
_TEXT	SEGMENT
_PIC_Initialize PROC

; 130  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 131  : /*goto commands iare used to make delay only as required by some PICs. Function calling here does not make that delay as they are inline (by __forceinline) ;)*/
; 132  : 
; 133  : 	//ICW1:::::::>>>>>>>
; 134  : 	//Pic0:
; 135  : 	PIC_SendCommand(0,
; 136  : 		 PIC_ICW1_ICW4_Yes
; 137  : 		|PIC_ICW1_Initialize
; 138  : 		|PIC_ICW1_LTIM_EdgeTriggered
; 139  : 		|PIC_ICW1_SNGL_CascadedPics);

  00003	6a 11		 push	 17			; 00000011H
  00005	6a 00		 push	 0
  00007	e8 00 00 00 00	 call	 _PIC_SendCommand
  0000c	83 c4 08	 add	 esp, 8
$A$998:

; 140  : 	
; 141  : 	goto A;
; 142  : 
; 143  : 	//Pic1:
; 144  : A:	PIC_SendCommand(1,
; 145  : 		 PIC_ICW1_ICW4_Yes
; 146  : 		|PIC_ICW1_Initialize
; 147  : 		|PIC_ICW1_LTIM_EdgeTriggered
; 148  : 		|PIC_ICW1_SNGL_CascadedPics);

  0000f	6a 11		 push	 17			; 00000011H
  00011	6a 01		 push	 1
  00013	e8 00 00 00 00	 call	 _PIC_SendCommand
  00018	83 c4 08	 add	 esp, 8
$B$999:

; 149  : 
; 150  : 	
; 151  : 	goto B;
; 152  : 
; 153  : 
; 154  : 	//ICW2::::::>>>>>
; 155  : 	//Pic0:
; 156  : B:	PIC_WriteData(0, PIC_BaseAddress_Pic1);

  0001b	6a 20		 push	 32			; 00000020H
  0001d	6a 00		 push	 0
  0001f	e8 00 00 00 00	 call	 _PIC_WriteData
  00024	83 c4 08	 add	 esp, 8
$c$1000:

; 157  : 	
; 158  : 	goto c;
; 159  : 
; 160  : 	//Pic1:
; 161  : c:	PIC_WriteData(1, PIC_BaseAddress_Pic2);

  00027	6a 28		 push	 40			; 00000028H
  00029	6a 01		 push	 1
  0002b	e8 00 00 00 00	 call	 _PIC_WriteData
  00030	83 c4 08	 add	 esp, 8
$D$1001:

; 162  : 
; 163  : 
; 164  : 	goto D;
; 165  : 
; 166  : 
; 167  : 	//ICW3::::::>>>>>>>>
; 168  : 	//Pic0:
; 169  : D:	PIC_WriteData(0, 0x04);	//0x00000100	each bit correspond to IRQ pin.

  00033	6a 04		 push	 4
  00035	6a 00		 push	 0
  00037	e8 00 00 00 00	 call	 _PIC_WriteData
  0003c	83 c4 08	 add	 esp, 8
$E$1002:

; 170  : 	
; 171  : 	goto E;
; 172  : 
; 173  : 	//Pic1:
; 174  : E:	PIC_WriteData(1, 0x02);	//0x00000010	write the value in ordinary binary!

  0003f	6a 02		 push	 2
  00041	6a 01		 push	 1
  00043	e8 00 00 00 00	 call	 _PIC_WriteData
  00048	83 c4 08	 add	 esp, 8
$F$1003:

; 175  : 
; 176  : 
; 177  : 	goto F;
; 178  : 
; 179  : 
; 180  : 	//ICW4::::::>>>>>>>>>
; 181  : 	//Pic0:
; 182  : F:	PIC_WriteData(0,
; 183  : 		 PIC_ICW4_AEOI_ManualEOI
; 184  : 		|PIC_ICW4_BUF_DisBuffer
; 185  : 		|PIC_ICW4_uPM_80x86);

  0004b	6a 01		 push	 1
  0004d	6a 00		 push	 0
  0004f	e8 00 00 00 00	 call	 _PIC_WriteData
  00054	83 c4 08	 add	 esp, 8
$G$1004:

; 186  : 
; 187  : 	goto G;
; 188  : 
; 189  : 	//Pic1:
; 190  : G:	PIC_WriteData(1,
; 191  : 		 PIC_ICW4_AEOI_ManualEOI
; 192  : 		|PIC_ICW4_BUF_DisBuffer
; 193  : 		|PIC_ICW4_uPM_80x86);

  00057	6a 01		 push	 1
  00059	6a 01		 push	 1
  0005b	e8 00 00 00 00	 call	 _PIC_WriteData
  00060	83 c4 08	 add	 esp, 8
$H$1005:

; 194  : 
; 195  : 	goto H;
; 196  : 
; 197  : 
; 198  : 	//Disable all HW interrupts
; 199  : H:	PIC_WriteData(0,0xFF);

  00063	68 ff 00 00 00	 push	 255			; 000000ffH
  00068	6a 00		 push	 0
  0006a	e8 00 00 00 00	 call	 _PIC_WriteData
  0006f	83 c4 08	 add	 esp, 8
$I$1006:

; 200  : 
; 201  : 	goto I;
; 202  : 
; 203  : I:	PIC_WriteData(1,0xFF);

  00072	68 ff 00 00 00	 push	 255			; 000000ffH
  00077	6a 01		 push	 1
  00079	e8 00 00 00 00	 call	 _PIC_WriteData
  0007e	83 c4 08	 add	 esp, 8

; 204  : 
; 205  : 	EnableIRQ(1);

  00081	6a 01		 push	 1
  00083	e8 00 00 00 00	 call	 _EnableIRQ
  00088	83 c4 04	 add	 esp, 4

; 206  : 	
; 207  : }

  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
_PIC_Initialize ENDP
_TEXT	ENDS
EXTRN	_OutPort:PROC
; Function compile flags: /Odtpy
;	COMDAT _PIC_SendCommand
_TEXT	SEGMENT
_Address$ = -4						; size = 2
_PicNO$ = 8						; size = 1
_Command$ = 12						; size = 1
_PIC_SendCommand PROC					; COMDAT

; 51   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 52   : 
; 53   : 	uint16 Address;
; 54   : 
; 55   : 	if (PicNO != 1 && PicNO != 0)  return;

  00004	0f b6 45 08	 movzx	 eax, BYTE PTR _PicNO$[ebp]
  00008	83 f8 01	 cmp	 eax, 1
  0000b	74 0a		 je	 SHORT $LN1@PIC_SendCo
  0000d	0f b6 4d 08	 movzx	 ecx, BYTE PTR _PicNO$[ebp]
  00011	85 c9		 test	 ecx, ecx
  00013	74 02		 je	 SHORT $LN1@PIC_SendCo
  00015	eb 27		 jmp	 SHORT $LN2@PIC_SendCo
$LN1@PIC_SendCo:

; 56   : 
; 57   : 	Address = (PicNO == 0)?  PIC_Ports_Pic0_Command : PIC_Ports_Pic1_Command;

  00017	0f b6 55 08	 movzx	 edx, BYTE PTR _PicNO$[ebp]
  0001b	f7 da		 neg	 edx
  0001d	1b d2		 sbb	 edx, edx
  0001f	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00025	83 c2 20	 add	 edx, 32			; 00000020H
  00028	66 89 55 fc	 mov	 WORD PTR _Address$[ebp], dx

; 58   : 
; 59   : 	OutPort(Address, Command);

  0002c	0f b6 45 0c	 movzx	 eax, BYTE PTR _Command$[ebp]
  00030	50		 push	 eax
  00031	0f b7 4d fc	 movzx	 ecx, WORD PTR _Address$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _OutPort
  0003b	83 c4 08	 add	 esp, 8
$LN2@PIC_SendCo:

; 60   : 
; 61   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_PIC_SendCommand ENDP
; Function compile flags: /Odtpy
_TEXT	ENDS
;	COMDAT _PIC_WriteData
_TEXT	SEGMENT
_Address$ = -4						; size = 2
_PicNO$ = 8						; size = 1
_Data$ = 12						; size = 1
_PIC_WriteData PROC					; COMDAT

; 81   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 82   : 
; 83   : 	uint16 Address;
; 84   : 
; 85   : 	if (PicNO != 1 && PicNO != 0)  return;

  00004	0f b6 45 08	 movzx	 eax, BYTE PTR _PicNO$[ebp]
  00008	83 f8 01	 cmp	 eax, 1
  0000b	74 0a		 je	 SHORT $LN1@PIC_WriteD
  0000d	0f b6 4d 08	 movzx	 ecx, BYTE PTR _PicNO$[ebp]
  00011	85 c9		 test	 ecx, ecx
  00013	74 02		 je	 SHORT $LN1@PIC_WriteD
  00015	eb 27		 jmp	 SHORT $LN2@PIC_WriteD
$LN1@PIC_WriteD:

; 86   : 
; 87   : 	Address = (PicNO == 0 )? PIC_Ports_Pic0_Data : PIC_Ports_Pic1_Data;

  00017	0f b6 55 08	 movzx	 edx, BYTE PTR _PicNO$[ebp]
  0001b	f7 da		 neg	 edx
  0001d	1b d2		 sbb	 edx, edx
  0001f	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00025	83 c2 21	 add	 edx, 33			; 00000021H
  00028	66 89 55 fc	 mov	 WORD PTR _Address$[ebp], dx

; 88   : 
; 89   : 	OutPort(Address, Data);

  0002c	0f b6 45 0c	 movzx	 eax, BYTE PTR _Data$[ebp]
  00030	50		 push	 eax
  00031	0f b7 4d fc	 movzx	 ecx, WORD PTR _Address$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 _OutPort
  0003b	83 c4 08	 add	 esp, 8
$LN2@PIC_WriteD:

; 90   : 
; 91   : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_PIC_WriteData ENDP
_TEXT	ENDS
PUBLIC	_PIC_ReadData
PUBLIC	_DisableIRQ
; Function compile flags: /Odtpy
_TEXT	SEGMENT
tv73 = -8						; size = 4
_Data$ = -2						; size = 1
_PIC$ = -1						; size = 1
_IRQNo$ = 8						; size = 1
_DisableIRQ PROC

; 213  : {

  00090	55		 push	 ebp
  00091	8b ec		 mov	 ebp, esp
  00093	83 ec 08	 sub	 esp, 8

; 214  : 	uint8 Data;
; 215  : 	uint8 PIC;
; 216  : 
; 217  : 	if (IRQNo > 15) return ;

  00096	0f b6 45 08	 movzx	 eax, BYTE PTR _IRQNo$[ebp]
  0009a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0009d	7e 02		 jle	 SHORT $LN1@DisableIRQ
  0009f	eb 5a		 jmp	 SHORT $LN2@DisableIRQ
$LN1@DisableIRQ:

; 218  : 	
; 219  : 	(IRQNo < 8)? (PIC = 0) : (PIC=1, IRQNo -= 8) ;

  000a1	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  000a5	83 f9 08	 cmp	 ecx, 8
  000a8	7d 0d		 jge	 SHORT $LN4@DisableIRQ
  000aa	c6 45 ff 00	 mov	 BYTE PTR _PIC$[ebp], 0
  000ae	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  000b2	89 55 f8	 mov	 DWORD PTR tv73[ebp], edx
  000b5	eb 15		 jmp	 SHORT $LN5@DisableIRQ
$LN4@DisableIRQ:
  000b7	c6 45 ff 01	 mov	 BYTE PTR _PIC$[ebp], 1
  000bb	0f b6 45 08	 movzx	 eax, BYTE PTR _IRQNo$[ebp]
  000bf	83 e8 08	 sub	 eax, 8
  000c2	88 45 08	 mov	 BYTE PTR _IRQNo$[ebp], al
  000c5	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  000c9	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN5@DisableIRQ:

; 220  : 
; 221  : 	Data = PIC_ReadData(PIC);

  000cc	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 _PIC_ReadData
  000d6	83 c4 04	 add	 esp, 4
  000d9	88 45 fe	 mov	 BYTE PTR _Data$[ebp], al
$A$1013:

; 222  : 
; 223  : 	goto A;
; 224  : A:	PIC_WriteData(PIC, GetMaskDis(IRQNo,Data));

  000dc	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  000e0	b8 01 00 00 00	 mov	 eax, 1
  000e5	d3 e0		 shl	 eax, cl
  000e7	0f b6 4d fe	 movzx	 ecx, BYTE PTR _Data$[ebp]
  000eb	0b c1		 or	 eax, ecx
  000ed	50		 push	 eax
  000ee	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 _PIC_WriteData
  000f8	83 c4 08	 add	 esp, 8
$LN2@DisableIRQ:

; 225  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
_DisableIRQ ENDP
_TEXT	ENDS
EXTRN	_InPort:PROC
; Function compile flags: /Odtpy
;	COMDAT _PIC_ReadData
_TEXT	SEGMENT
_Address$ = -4						; size = 2
_PicNO$ = 8						; size = 1
_PIC_ReadData PROC					; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 98   : 
; 99   : 	uint16 Address;
; 100  : 
; 101  : 	if (PicNO != 1 && PicNO != 0)  return 0;

  00004	0f b6 45 08	 movzx	 eax, BYTE PTR _PicNO$[ebp]
  00008	83 f8 01	 cmp	 eax, 1
  0000b	74 0c		 je	 SHORT $LN1@PIC_ReadDa
  0000d	0f b6 4d 08	 movzx	 ecx, BYTE PTR _PicNO$[ebp]
  00011	85 c9		 test	 ecx, ecx
  00013	74 04		 je	 SHORT $LN1@PIC_ReadDa
  00015	32 c0		 xor	 al, al
  00017	eb 22		 jmp	 SHORT $LN2@PIC_ReadDa
$LN1@PIC_ReadDa:

; 102  : 
; 103  : 	Address = (PicNO == 0 )? PIC_Ports_Pic0_Data : PIC_Ports_Pic1_Data;

  00019	0f b6 55 08	 movzx	 edx, BYTE PTR _PicNO$[ebp]
  0001d	f7 da		 neg	 edx
  0001f	1b d2		 sbb	 edx, edx
  00021	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  00027	83 c2 21	 add	 edx, 33			; 00000021H
  0002a	66 89 55 fc	 mov	 WORD PTR _Address$[ebp], dx

; 104  : 
; 105  : 	return InPort(Address);

  0002e	0f b7 45 fc	 movzx	 eax, WORD PTR _Address$[ebp]
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 _InPort
  00038	83 c4 04	 add	 esp, 4
$LN2@PIC_ReadDa:

; 106  : 	
; 107  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
_PIC_ReadData ENDP
; Function compile flags: /Odtpy
_TEXT	ENDS
_TEXT	SEGMENT
tv73 = -8						; size = 4
_Data$ = -2						; size = 1
_PIC$ = -1						; size = 1
_IRQNo$ = 8						; size = 1
_EnableIRQ PROC

; 230  : {

  00100	55		 push	 ebp
  00101	8b ec		 mov	 ebp, esp
  00103	83 ec 08	 sub	 esp, 8

; 231  : 	uint8 Data;
; 232  : 	uint8 PIC;
; 233  : 
; 234  : 	if (IRQNo > 15) return ;

  00106	0f b6 45 08	 movzx	 eax, BYTE PTR _IRQNo$[ebp]
  0010a	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  0010d	7e 02		 jle	 SHORT $LN1@EnableIRQ
  0010f	eb 5c		 jmp	 SHORT $LN2@EnableIRQ
$LN1@EnableIRQ:

; 235  : 	
; 236  : 	(IRQNo < 8)? (PIC=0) : (PIC=1, IRQNo -= 8) ;

  00111	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  00115	83 f9 08	 cmp	 ecx, 8
  00118	7d 0d		 jge	 SHORT $LN4@EnableIRQ
  0011a	c6 45 ff 00	 mov	 BYTE PTR _PIC$[ebp], 0
  0011e	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  00122	89 55 f8	 mov	 DWORD PTR tv73[ebp], edx
  00125	eb 15		 jmp	 SHORT $LN5@EnableIRQ
$LN4@EnableIRQ:
  00127	c6 45 ff 01	 mov	 BYTE PTR _PIC$[ebp], 1
  0012b	0f b6 45 08	 movzx	 eax, BYTE PTR _IRQNo$[ebp]
  0012f	83 e8 08	 sub	 eax, 8
  00132	88 45 08	 mov	 BYTE PTR _IRQNo$[ebp], al
  00135	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  00139	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN5@EnableIRQ:

; 237  : 
; 238  : 	Data = PIC_ReadData(PIC);

  0013c	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  00140	52		 push	 edx
  00141	e8 00 00 00 00	 call	 _PIC_ReadData
  00146	83 c4 04	 add	 esp, 4
  00149	88 45 fe	 mov	 BYTE PTR _Data$[ebp], al
$A$1020:

; 239  : 
; 240  : 	goto A;
; 241  : 
; 242  : A:	PIC_WriteData(PIC, GetMaskEN(IRQNo,Data));

  0014c	0f b6 4d 08	 movzx	 ecx, BYTE PTR _IRQNo$[ebp]
  00150	b8 01 00 00 00	 mov	 eax, 1
  00155	d3 e0		 shl	 eax, cl
  00157	f7 d0		 not	 eax
  00159	0f b6 4d fe	 movzx	 ecx, BYTE PTR _Data$[ebp]
  0015d	23 c1		 and	 eax, ecx
  0015f	50		 push	 eax
  00160	0f b6 55 ff	 movzx	 edx, BYTE PTR _PIC$[ebp]
  00164	52		 push	 edx
  00165	e8 00 00 00 00	 call	 _PIC_WriteData
  0016a	83 c4 08	 add	 esp, 8
$LN2@EnableIRQ:

; 243  : }

  0016d	8b e5		 mov	 esp, ebp
  0016f	5d		 pop	 ebp
  00170	c3		 ret	 0
_EnableIRQ ENDP
_TEXT	ENDS
PUBLIC	_EnableHWInt
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_EnableHWInt PROC

; 249  : {

  00180	55		 push	 ebp
  00181	8b ec		 mov	 ebp, esp

; 250  : 	_asm sti

  00183	fb		 sti

; 251  : }

  00184	5d		 pop	 ebp
  00185	c3		 ret	 0
_EnableHWInt ENDP
_TEXT	ENDS
PUBLIC	_DisableHWInt
; Function compile flags: /Odtpy
_TEXT	SEGMENT
_DisableHWInt PROC

; 255  : {

  00190	55		 push	 ebp
  00191	8b ec		 mov	 ebp, esp

; 256  : 	_asm cli

  00193	fa		 cli

; 257  : }

  00194	5d		 pop	 ebp
  00195	c3		 ret	 0
_DisableHWInt ENDP
_TEXT	ENDS
END
